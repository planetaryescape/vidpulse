import type {
	ApiKeys,
	CacheEntry,
	ChannelStats,
	DailyStats,
	FocusSchedule,
	LikedChannel,
	MemoryEntry,
	ModelConfig,
	NotesIndex,
	SessionData,
	SessionVideo,
	Settings,
	VideoAnalysis,
	VideoFeedback,
	VideoNote,
	VideoSource,
} from "./types";

const DEFAULT_MODELS: ModelConfig = {
	videoReading: "gemini-3-flash-preview",
	summarization: "gemini-2.0-flash",
	recommendationReasoning: "gemini-2.0-flash",
	tagGeneration: "gemini-2.0-flash",
	transcriptAnalysis: "gemini-2.0-flash",
	memoryExtraction: "gemini-2.0-flash",
};

const DEFAULT_SETTINGS: Settings = {
	apiKey: "",
	models: DEFAULT_MODELS,
	cacheExpiry: 365, // days (1 year default)
	fontSize: 1, // 1 = 100%
	aboutMe: "",
	manualPreferences: "",
	aboutMeAutoGenerated: true,
	guardianEnabled: false,
	minScoreThreshold: 40,
	blockedTags: [],
	preferencesVersion: 1,
	checkInEnabled: true,
	checkInInterval: 30, // 30 minutes default
};

const CACHE_PREFIX = "cache_";
const MEMORIES_KEY = "vidpulse_memories";
const FEEDBACK_KEY = "vidpulse_feedback";
const API_KEYS_KEY = "vidpulse_api_keys";

// API keys stored in local storage only (not synced for security)
async function getApiKeys(): Promise<ApiKeys> {
	const result = await chrome.storage.local.get(API_KEYS_KEY);
	return (result[API_KEYS_KEY] as ApiKeys | undefined) || { apiKey: "" };
}

async function saveApiKeys(keys: Partial<ApiKeys>): Promise<void> {
	const current = await getApiKeys();
	await chrome.storage.local.set({ [API_KEYS_KEY]: { ...current, ...keys } });
}

// Migrate API keys from sync to local storage (one-time migration)
export async function migrateApiKeysToLocal(): Promise<void> {
	const localKeys = await getApiKeys();
	if (localKeys.apiKey) return; // Already migrated

	const syncResult = await chrome.storage.sync.get("settings");
	const syncSettings = (syncResult.settings || {}) as Partial<Settings> &
		Record<string, unknown>;

	if (syncSettings.apiKey || syncSettings.braveApiKey) {
		// Copy keys to local storage
		await saveApiKeys({
			apiKey: syncSettings.apiKey || "",
			braveApiKey: syncSettings.braveApiKey,
		});

		// Remove keys from sync storage
		delete syncSettings.apiKey;
		delete syncSettings.braveApiKey;
		await chrome.storage.sync.set({ settings: syncSettings });
	}
}

// Settings (synced across devices, except API keys which are local-only)
export async function getSettings(): Promise<Settings> {
	const [syncResult, apiKeys] = await Promise.all([
		chrome.storage.sync.get("settings"),
		getApiKeys(),
	]);
	const syncSettings = (syncResult.settings || {}) as Partial<Settings>;
	return {
		...DEFAULT_SETTINGS,
		...syncSettings,
		apiKey: apiKeys.apiKey || "",
		braveApiKey: apiKeys.braveApiKey,
	};
}

// Check if preference-affecting settings changed
function preferencesChanged(
	current: Settings,
	updates: Partial<Settings>,
): boolean {
	// Check aboutMe
	if ("aboutMe" in updates && updates.aboutMe !== current.aboutMe) {
		return true;
	}
	// Check models (any model change affects cache)
	if ("models" in updates && updates.models) {
		const currentModels = current.models;
		const newModels = updates.models;
		for (const key of Object.keys(newModels) as (keyof ModelConfig)[]) {
			if (newModels[key] !== currentModels[key]) {
				return true;
			}
		}
	}
	return false;
}

export async function saveSettings(settings: Partial<Settings>): Promise<void> {
	const current = await getSettings();

	// Increment version if preferences changed (invalidates cache)
	let newVersion = current.preferencesVersion;
	if (preferencesChanged(current, settings)) {
		newVersion = (current.preferencesVersion || 1) + 1;
	}

	// Extract API keys for local storage
	const apiKeyUpdates: Partial<ApiKeys> = {};
	if ("apiKey" in settings) apiKeyUpdates.apiKey = settings.apiKey;
	if ("braveApiKey" in settings)
		apiKeyUpdates.braveApiKey = settings.braveApiKey;

	// Prepare sync settings (exclude API keys)
	const {
		apiKey: _apiKey,
		braveApiKey: _braveApiKey,
		...syncableUpdates
	} = settings;
	const syncData = {
		...current,
		...syncableUpdates,
		preferencesVersion: newVersion,
	};
	delete (syncData as Record<string, unknown>).apiKey;
	delete (syncData as Record<string, unknown>).braveApiKey;

	// Save to both storage areas
	await Promise.all([
		chrome.storage.sync.set({ settings: syncData }),
		Object.keys(apiKeyUpdates).length > 0
			? saveApiKeys(apiKeyUpdates)
			: Promise.resolve(),
	]);
}

// Cache (local only)
export async function getCached(
	videoId: string,
): Promise<VideoAnalysis | null> {
	const key = `${CACHE_PREFIX}${videoId}`;
	const result = await chrome.storage.local.get(key);
	const entry = result[key] as CacheEntry | undefined;

	if (!entry) return null;

	const settings = await getSettings();

	// Check if preferences changed (version mismatch)
	if (entry.preferencesVersion !== settings.preferencesVersion) {
		await chrome.storage.local.remove(key);
		return null;
	}

	// Check expiry
	const expiryMs = settings.cacheExpiry * 24 * 60 * 60 * 1000;
	if (Date.now() - entry.timestamp > expiryMs) {
		await chrome.storage.local.remove(key);
		return null;
	}

	return entry.analysis;
}

export async function setCache(
	videoId: string,
	analysis: VideoAnalysis,
): Promise<void> {
	const settings = await getSettings();
	const key = `${CACHE_PREFIX}${videoId}`;
	const entry: CacheEntry = {
		videoId,
		analysis,
		timestamp: Date.now(),
		preferencesVersion: settings.preferencesVersion,
	};
	await chrome.storage.local.set({ [key]: entry });
}

export async function clearVideoCache(videoId: string): Promise<void> {
	const key = `${CACHE_PREFIX}${videoId}`;
	await chrome.storage.local.remove(key);
}

export async function cleanupCache(): Promise<void> {
	const settings = await getSettings();
	const expiryMs = settings.cacheExpiry * 24 * 60 * 60 * 1000;
	const all = await chrome.storage.local.get(null);

	const keysToRemove: string[] = [];
	for (const [key, value] of Object.entries(all)) {
		if (key.startsWith(CACHE_PREFIX)) {
			const entry = value as CacheEntry;
			// Remove if expired or preferences version mismatch
			if (
				Date.now() - entry.timestamp > expiryMs ||
				entry.preferencesVersion !== settings.preferencesVersion
			) {
				keysToRemove.push(key);
			}
		}
	}

	if (keysToRemove.length > 0) {
		await chrome.storage.local.remove(keysToRemove);
	}
}

// Migrate old single-source MemoryEntry to new multi-source format
function migrateMemoryEntry(entry: MemoryEntry): MemoryEntry {
	// Already migrated
	if (entry.sources && entry.sources.length > 0) {
		return entry;
	}
	// Migrate from deprecated single-source fields
	if (entry.sourceVideoId && entry.sourceVideoTitle) {
		return {
			...entry,
			sources: [
				{
					videoId: entry.sourceVideoId,
					videoTitle: entry.sourceVideoTitle,
					timestamp: entry.sourceTimestamp,
					addedAt: entry.createdAt,
				},
			],
		};
	}
	// Fallback: empty sources (shouldn't happen)
	return { ...entry, sources: [] };
}

// Memory storage (synced across devices)
export async function getMemories(): Promise<MemoryEntry[]> {
	const result = await chrome.storage.sync.get(MEMORIES_KEY);
	const raw = (result[MEMORIES_KEY] || []) as MemoryEntry[];
	return raw.map(migrateMemoryEntry);
}

async function incrementPreferencesVersion(): Promise<void> {
	const settings = await getSettings();
	await chrome.storage.sync.set({
		settings: {
			...settings,
			preferencesVersion: settings.preferencesVersion + 1,
		},
	});
}

// Debounced regeneration of aboutMe
let regenerateTimeout: ReturnType<typeof setTimeout> | null = null;
const REGENERATE_DEBOUNCE_MS = 2000;

async function triggerRegenerateAboutMe(): Promise<void> {
	if (regenerateTimeout) {
		clearTimeout(regenerateTimeout);
	}
	regenerateTimeout = setTimeout(async () => {
		try {
			await chrome.runtime.sendMessage({ type: "REGENERATE_ABOUT_ME" });
		} catch {
			// Ignore errors (e.g., if service worker not ready)
		}
	}, REGENERATE_DEBOUNCE_MS);
}

export async function addMemory(memory: MemoryEntry): Promise<void> {
	const memories = await getMemories();
	memories.push(memory);
	await chrome.storage.sync.set({ [MEMORIES_KEY]: memories });
	await incrementPreferencesVersion();
	await triggerRegenerateAboutMe();
}

export async function addMemories(newMemories: MemoryEntry[]): Promise<void> {
	const memories = await getMemories();
	memories.push(...newMemories);
	await chrome.storage.sync.set({ [MEMORIES_KEY]: memories });
	await incrementPreferencesVersion();
	await triggerRegenerateAboutMe();
}

export async function removeMemory(memoryId: string): Promise<void> {
	const memories = await getMemories();
	const filtered = memories.filter((m) => m.id !== memoryId);
	await chrome.storage.sync.set({ [MEMORIES_KEY]: filtered });
	await incrementPreferencesVersion();
	await triggerRegenerateAboutMe();
}

export async function clearMemories(): Promise<void> {
	await chrome.storage.sync.remove(MEMORIES_KEY);
	await incrementPreferencesVersion();
	await triggerRegenerateAboutMe();
}

// Update a specific memory (for merging sources)
export async function updateMemory(
	memoryId: string,
	updates: Partial<MemoryEntry>,
): Promise<void> {
	const memories = await getMemories();
	const index = memories.findIndex((m) => m.id === memoryId);
	if (index === -1) return;

	memories[index] = { ...memories[index], ...updates, updatedAt: Date.now() };
	await chrome.storage.sync.set({ [MEMORIES_KEY]: memories });
	await incrementPreferencesVersion();
	await triggerRegenerateAboutMe();
}

// Merge a new source into an existing memory
export async function mergeMemorySource(
	memoryId: string,
	newSource: VideoSource,
	newConfidence: number,
	newPreferenceText?: string,
): Promise<void> {
	const memories = await getMemories();
	const memory = memories.find((m) => m.id === memoryId);
	if (!memory) return;

	// Add source if video not already in sources
	const hasVideo = memory.sources.some((s) => s.videoId === newSource.videoId);
	if (!hasVideo) {
		memory.sources.push(newSource);
	}

	// Take higher confidence
	memory.confidence = Math.max(memory.confidence, newConfidence);

	// Update preference text if provided (AI-rewritten)
	if (newPreferenceText) {
		memory.preference = newPreferenceText;
	}

	memory.updatedAt = Date.now();
	await chrome.storage.sync.set({ [MEMORIES_KEY]: memories });
	await incrementPreferencesVersion();
	await triggerRegenerateAboutMe();
}

// Replace all memories (for batch condense)
export async function replaceMemories(
	newMemories: MemoryEntry[],
): Promise<void> {
	await chrome.storage.sync.set({ [MEMORIES_KEY]: newMemories });
	await incrementPreferencesVersion();
	await triggerRegenerateAboutMe();
}

// Feedback history (local only, for reference)
export async function getFeedbackHistory(): Promise<VideoFeedback[]> {
	const result = await chrome.storage.local.get(FEEDBACK_KEY);
	return (result[FEEDBACK_KEY] || []) as VideoFeedback[];
}

export async function addFeedback(feedback: VideoFeedback): Promise<void> {
	const history = await getFeedbackHistory();
	history.push(feedback);
	// Keep last 100 entries
	const trimmed = history.slice(-100);
	await chrome.storage.local.set({ [FEEDBACK_KEY]: trimmed });
}

export async function getFeedbackForVideo(
	videoId: string,
): Promise<VideoFeedback | null> {
	const history = await getFeedbackHistory();
	return history.find((f) => f.videoId === videoId) || null;
}

// Session storage (uses chrome.storage.session - cleared when browser closes)
const SESSION_KEY = "vidpulse_session";
const SESSION_INACTIVITY_TIMEOUT = 30 * 60 * 1000; // 30 minutes

export async function getSession(): Promise<SessionData | null> {
	const result = await chrome.storage.session.get(SESSION_KEY);
	const session = result[SESSION_KEY] as SessionData | undefined;

	if (!session) return null;

	// Check for inactivity timeout
	if (Date.now() - session.lastActivity > SESSION_INACTIVITY_TIMEOUT) {
		await chrome.storage.session.remove(SESSION_KEY);
		return null;
	}

	return session;
}

export async function startSession(): Promise<SessionData> {
	const now = Date.now();
	const session: SessionData = {
		startTime: now,
		lastActivity: now,
		videos: [],
	};
	await chrome.storage.session.set({ [SESSION_KEY]: session });
	return session;
}

export async function updateSessionActivity(): Promise<void> {
	const session = await getSession();
	if (session) {
		session.lastActivity = Date.now();
		await chrome.storage.session.set({ [SESSION_KEY]: session });
	}
}

export async function addVideoToSession(video: SessionVideo): Promise<void> {
	let session = await getSession();
	if (!session) {
		session = await startSession();
	}

	// Check if video already in session
	const existing = session.videos.find((v) => v.videoId === video.videoId);
	if (existing) {
		// Update existing entry
		Object.assign(existing, video);
	} else {
		session.videos.push(video);
	}

	session.lastActivity = Date.now();
	await chrome.storage.session.set({ [SESSION_KEY]: session });
}

export async function endVideoInSession(videoId: string): Promise<void> {
	const session = await getSession();
	if (!session) return;

	const video = session.videos.find((v) => v.videoId === videoId);
	if (video && !video.endTime) {
		video.endTime = Date.now();
		await chrome.storage.session.set({ [SESSION_KEY]: session });
	}
}

export async function setSessionIntent(
	intent: SessionData["intent"],
): Promise<void> {
	const session = await getSession();
	if (session) {
		session.intent = intent;
		await chrome.storage.session.set({ [SESSION_KEY]: session });
	}
}

export async function clearSession(): Promise<void> {
	await chrome.storage.session.remove(SESSION_KEY);
}

// Channel stats storage (local)
const CHANNEL_STATS_KEY = "vidpulse_channel_stats";

export async function getChannelStats(): Promise<Record<string, ChannelStats>> {
	const result = await chrome.storage.local.get(CHANNEL_STATS_KEY);
	return (result[CHANNEL_STATS_KEY] || {}) as Record<string, ChannelStats>;
}

export async function updateChannelStats(
	channelId: string,
	channelName: string,
	scores: {
		productivity: number;
		educational: number;
		entertainment: number;
		inspiring: number;
		creative: number;
	},
): Promise<ChannelStats> {
	const allStats = await getChannelStats();
	const existing = allStats[channelId];

	if (existing) {
		existing.videoCount += 1;
		existing.totalScores.productivity += scores.productivity;
		existing.totalScores.educational += scores.educational;
		existing.totalScores.entertainment += scores.entertainment;
		existing.totalScores.inspiring += scores.inspiring;
		existing.totalScores.creative += scores.creative;
		existing.avgScores.productivity = Math.round(
			existing.totalScores.productivity / existing.videoCount,
		);
		existing.avgScores.educational = Math.round(
			existing.totalScores.educational / existing.videoCount,
		);
		existing.avgScores.entertainment = Math.round(
			existing.totalScores.entertainment / existing.videoCount,
		);
		existing.avgScores.inspiring = Math.round(
			existing.totalScores.inspiring / existing.videoCount,
		);
		existing.avgScores.creative = Math.round(
			existing.totalScores.creative / existing.videoCount,
		);
		existing.lastUpdated = Date.now();
		allStats[channelId] = existing;
	} else {
		allStats[channelId] = {
			channelId,
			channelName,
			videoCount: 1,
			totalScores: { ...scores },
			avgScores: { ...scores },
			lastUpdated: Date.now(),
		};
	}

	await chrome.storage.local.set({ [CHANNEL_STATS_KEY]: allStats });
	return allStats[channelId];
}

export async function setChannelTrust(
	channelId: string,
	trust: "trusted" | "blocked" | null,
): Promise<void> {
	const allStats = await getChannelStats();
	if (allStats[channelId]) {
		allStats[channelId].manualTrust = trust;
		await chrome.storage.local.set({ [CHANNEL_STATS_KEY]: allStats });
	}
}

// Liked channels storage (local)
const LIKED_CHANNELS_KEY = "vidpulse_liked_channels";

export async function getLikedChannels(): Promise<
	Record<string, LikedChannel>
> {
	const result = await chrome.storage.local.get(LIKED_CHANNELS_KEY);
	return (result[LIKED_CHANNELS_KEY] || {}) as Record<string, LikedChannel>;
}

export async function addLikedChannel(
	channelId: string,
	channelName: string,
	channelUrl: string,
	videoId: string,
	videoTitle: string,
	scores?: {
		productivity: number;
		educational: number;
		entertainment: number;
		inspiring?: number;
		creative?: number;
	},
): Promise<void> {
	const channels = await getLikedChannels();
	const now = Date.now();

	if (channels[channelId]) {
		const ch = channels[channelId];
		if (!ch.likedVideoIds.includes(videoId)) {
			ch.likedVideoIds.push(videoId);
			ch.likedVideoTitles.push(videoTitle);
		}
		ch.lastLikedAt = now;
		if (scores && ch.avgScores) {
			const n = ch.likedVideoIds.length;
			ch.avgScores = {
				productivity: Math.round(
					(ch.avgScores.productivity * (n - 1) + scores.productivity) / n,
				),
				educational: Math.round(
					(ch.avgScores.educational * (n - 1) + scores.educational) / n,
				),
				entertainment: Math.round(
					(ch.avgScores.entertainment * (n - 1) + scores.entertainment) / n,
				),
				inspiring: Math.round(
					(ch.avgScores.inspiring * (n - 1) + (scores.inspiring ?? 0)) / n,
				),
				creative: Math.round(
					(ch.avgScores.creative * (n - 1) + (scores.creative ?? 0)) / n,
				),
			};
		}
	} else {
		channels[channelId] = {
			channelId,
			channelName,
			channelUrl,
			likedVideoIds: [videoId],
			likedVideoTitles: [videoTitle],
			firstLikedAt: now,
			lastLikedAt: now,
			avgScores: scores
				? {
						productivity: scores.productivity,
						educational: scores.educational,
						entertainment: scores.entertainment,
						inspiring: scores.inspiring ?? 0,
						creative: scores.creative ?? 0,
					}
				: undefined,
		};
	}

	await chrome.storage.local.set({ [LIKED_CHANNELS_KEY]: channels });
}

export async function removeLikedChannel(channelId: string): Promise<void> {
	const channels = await getLikedChannels();
	delete channels[channelId];
	await chrome.storage.local.set({ [LIKED_CHANNELS_KEY]: channels });
}

export async function updateLikedChannelSubscription(
	channelId: string,
	status: "subscribed" | "not_subscribed" | "unknown",
): Promise<void> {
	const channels = await getLikedChannels();
	if (channels[channelId]) {
		channels[channelId].subscriptionStatus = status;
		channels[channelId].subscriptionCheckedAt = Date.now();
		await chrome.storage.local.set({ [LIKED_CHANNELS_KEY]: channels });
	}
}

// Daily stats storage (local)
const DAILY_STATS_KEY = "vidpulse_daily_stats";

function getTodayKey(): string {
	return new Date().toISOString().split("T")[0];
}

export async function getDailyStats(date?: string): Promise<DailyStats | null> {
	const key = date || getTodayKey();
	const result = await chrome.storage.local.get(DAILY_STATS_KEY);
	const allStats = (result[DAILY_STATS_KEY] || {}) as Record<
		string,
		DailyStats
	>;
	return allStats[key] || null;
}

export async function getAllDailyStats(): Promise<Record<string, DailyStats>> {
	const result = await chrome.storage.local.get(DAILY_STATS_KEY);
	return (result[DAILY_STATS_KEY] || {}) as Record<string, DailyStats>;
}

export async function updateDailyStats(
	watchTime: number,
	scores: {
		productivity: number;
		educational: number;
		entertainment: number;
		inspiring: number;
		creative: number;
	},
	channelId?: string,
): Promise<void> {
	const key = getTodayKey();
	const allStats = await getAllDailyStats();

	// Determine dominant category
	const maxScore = Math.max(
		scores.productivity,
		scores.educational,
		scores.entertainment,
		scores.inspiring,
		scores.creative,
	);
	const category =
		scores.educational === maxScore
			? "educational"
			: scores.entertainment === maxScore
				? "entertainment"
				: scores.inspiring === maxScore
					? "inspiring"
					: scores.creative === maxScore
						? "creative"
						: "productive";

	if (!allStats[key]) {
		allStats[key] = {
			date: key,
			totalTime: 0,
			videoCount: 0,
			byCategory: {
				educational: { count: 0, time: 0 },
				entertainment: { count: 0, time: 0 },
				productive: { count: 0, time: 0 },
				inspiring: { count: 0, time: 0 },
				creative: { count: 0, time: 0 },
			},
			avgScores: {
				productivity: 0,
				educational: 0,
				entertainment: 0,
				inspiring: 0,
				creative: 0,
			},
			guardianBlocks: 0,
			guardianOverrides: 0,
			channelsWatched: [],
		};
	}

	const stats = allStats[key];
	stats.totalTime += watchTime;
	stats.videoCount += 1;
	stats.byCategory[category].count += 1;
	stats.byCategory[category].time += watchTime;

	// Update average scores
	const n = stats.videoCount;
	stats.avgScores.productivity = Math.round(
		(stats.avgScores.productivity * (n - 1) + scores.productivity) / n,
	);
	stats.avgScores.educational = Math.round(
		(stats.avgScores.educational * (n - 1) + scores.educational) / n,
	);
	stats.avgScores.entertainment = Math.round(
		(stats.avgScores.entertainment * (n - 1) + scores.entertainment) / n,
	);
	stats.avgScores.inspiring = Math.round(
		(stats.avgScores.inspiring * (n - 1) + scores.inspiring) / n,
	);
	stats.avgScores.creative = Math.round(
		(stats.avgScores.creative * (n - 1) + scores.creative) / n,
	);

	if (channelId && !stats.channelsWatched.includes(channelId)) {
		stats.channelsWatched.push(channelId);
	}

	await chrome.storage.local.set({ [DAILY_STATS_KEY]: allStats });
}

export async function incrementGuardianBlock(): Promise<void> {
	const key = getTodayKey();
	const allStats = await getAllDailyStats();
	if (!allStats[key]) return;
	allStats[key].guardianBlocks += 1;
	await chrome.storage.local.set({ [DAILY_STATS_KEY]: allStats });
}

export async function incrementGuardianOverride(): Promise<void> {
	const key = getTodayKey();
	const allStats = await getAllDailyStats();
	if (!allStats[key]) return;
	allStats[key].guardianOverrides += 1;
	await chrome.storage.local.set({ [DAILY_STATS_KEY]: allStats });
}

// Focus schedule storage (synced)
const FOCUS_SCHEDULE_KEY = "vidpulse_focus_schedule";

const DEFAULT_FOCUS_SCHEDULE: FocusSchedule = {
	enabled: false,
	periods: [{ days: [1, 2, 3, 4, 5], startHour: 9, endHour: 17 }], // Mon-Fri 9-5
	focusThreshold: 60,
	blockEntertainment: true,
};

export async function getFocusSchedule(): Promise<FocusSchedule> {
	const result = await chrome.storage.sync.get(FOCUS_SCHEDULE_KEY);
	const stored = (result[FOCUS_SCHEDULE_KEY] || {}) as Partial<FocusSchedule>;
	return { ...DEFAULT_FOCUS_SCHEDULE, ...stored };
}

export async function saveFocusSchedule(
	schedule: Partial<FocusSchedule>,
): Promise<void> {
	const current = await getFocusSchedule();
	await chrome.storage.sync.set({
		[FOCUS_SCHEDULE_KEY]: { ...current, ...schedule },
	});
}

export async function pauseFocusMode(hours: number): Promise<void> {
	const schedule = await getFocusSchedule();
	schedule.pausedUntil = Date.now() + hours * 60 * 60 * 1000;
	await chrome.storage.sync.set({ [FOCUS_SCHEDULE_KEY]: schedule });
}

export function isInFocusPeriod(schedule: FocusSchedule): boolean {
	if (!schedule.enabled) return false;
	if (schedule.pausedUntil && Date.now() < schedule.pausedUntil) return false;

	const now = new Date();
	const day = now.getDay();
	const hour = now.getHours();

	return schedule.periods.some(
		(period) =>
			period.days.includes(day) &&
			hour >= period.startHour &&
			hour < period.endHour,
	);
}

// Video notes storage (local only)
const NOTES_KEY = "vidpulse_notes";

export async function getNotesForVideo(videoId: string): Promise<VideoNote[]> {
	const result = await chrome.storage.local.get(NOTES_KEY);
	const allNotes = (result[NOTES_KEY] || {}) as Record<string, VideoNote[]>;
	return (allNotes[videoId] || []).sort((a, b) => a.timestamp - b.timestamp);
}

export async function getAllNotesIndex(): Promise<NotesIndex[]> {
	const result = await chrome.storage.local.get(NOTES_KEY);
	const allNotes = (result[NOTES_KEY] || {}) as Record<string, VideoNote[]>;

	const index: NotesIndex[] = [];
	for (const [videoId, notes] of Object.entries(allNotes)) {
		if (notes.length > 0) {
			const lastNote = notes.reduce((a, b) =>
				a.updatedAt > b.updatedAt ? a : b,
			);
			index.push({
				videoId,
				videoTitle: notes[0].videoTitle,
				videoUrl: notes[0].videoUrl,
				noteCount: notes.length,
				lastNoteAt: lastNote.updatedAt,
			});
		}
	}

	return index.sort((a, b) => b.lastNoteAt - a.lastNoteAt);
}

export async function getAllNotes(): Promise<Record<string, VideoNote[]>> {
	const result = await chrome.storage.local.get(NOTES_KEY);
	return (result[NOTES_KEY] || {}) as Record<string, VideoNote[]>;
}

export async function addNote(note: VideoNote): Promise<void> {
	const result = await chrome.storage.local.get(NOTES_KEY);
	const allNotes = (result[NOTES_KEY] || {}) as Record<string, VideoNote[]>;

	if (!allNotes[note.videoId]) {
		allNotes[note.videoId] = [];
	}
	allNotes[note.videoId].push(note);

	await chrome.storage.local.set({ [NOTES_KEY]: allNotes });
}

export async function updateNote(
	videoId: string,
	noteId: string,
	content: string,
): Promise<void> {
	const result = await chrome.storage.local.get(NOTES_KEY);
	const allNotes = (result[NOTES_KEY] || {}) as Record<string, VideoNote[]>;

	const notes = allNotes[videoId];
	if (!notes) return;

	const note = notes.find((n) => n.id === noteId);
	if (note) {
		note.content = content;
		note.updatedAt = Date.now();
		await chrome.storage.local.set({ [NOTES_KEY]: allNotes });
	}
}

export async function deleteNote(
	videoId: string,
	noteId: string,
): Promise<void> {
	const result = await chrome.storage.local.get(NOTES_KEY);
	const allNotes = (result[NOTES_KEY] || {}) as Record<string, VideoNote[]>;

	if (!allNotes[videoId]) return;

	allNotes[videoId] = allNotes[videoId].filter((n) => n.id !== noteId);

	// Remove video entry if no notes left
	if (allNotes[videoId].length === 0) {
		delete allNotes[videoId];
	}

	await chrome.storage.local.set({ [NOTES_KEY]: allNotes });
}

export async function deleteAllNotesForVideo(videoId: string): Promise<void> {
	const result = await chrome.storage.local.get(NOTES_KEY);
	const allNotes = (result[NOTES_KEY] || {}) as Record<string, VideoNote[]>;

	delete allNotes[videoId];
	await chrome.storage.local.set({ [NOTES_KEY]: allNotes });
}
